/*
编程要求
对于任意一个x的2次多项式，假设各项的系数a、b、c和x的值均取整数。写一个程序，读取用户从键盘输入的一组系数a、b、c和x的值后，计算对应的二次多项式的值，并输出结果。

测试说明
平台会对你编写的代码进行测试：

测试输入：1 2 3，1
预期输出：6

#include <stdio.h>
#include <stdlib.h>
*/

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

/*
int main(int argc, char *argv[]) {
	int a, b, c, x = 0;
	int value = 0; 
	scanf("%d%d%d,%d", &a, &b, &c, &x);
	value = a*x*x + b*x + c;
	printf("%d", value);
	
	return 0;
}
*/

/*
问题描述
本关任务：给银行的柜员机编写一个硬币兑换计算程序。

相关知识
为了完成本关任务，你需要掌握如下知识：

多元一次方程的解
例如：
    x、y、z皆为正整数，且x+y+z=4，则有：
    x=1，y=1，z=2
    x=1，y=2，z=1
    x=2，y=1，z=1
   共3组解。

编程要求
当顾客把一些1元、5角、1角的硬币投入柜员机的入币口之后，柜员机就执行你写的程序，计算出应该兑换的10元纸币的数量和剩余硬币的数量，
并且在屏幕上显示计算结果，单击OK按钮之后，柜员机的出币口会把10元纸币及不足10元的硬币返回给顾客。
这里把硬币投入简化成顾客按顺序输入各种硬币的数量，输入的顺序是1元数、5角数、1角数，输出的结果为10元数、元数、角数，出币口出币的环节可以忽略。

测试说明
平台会对你编写的代码进行测试：

测试输入：15 23 106
预期输出：3 7 1
*/

/*
#include<stdio.h>
#include<stdlib.h>
int main(void){
	int yiyuan1, wujiao1, yijiao1 = 0;
	int shiyuan, yiyuan2, yijiao2 = 0;
	int temp, tem1, tem2 = 0;
	scanf("%d%d%d", &yiyuan1, &wujiao1, &yijiao1);
	temp = yiyuan1*10 + wujiao1*5 + yijiao1;
	if(temp%100==0)
	{
		shiyuan = temp / 100;
		yiyuan2 = 0;
		yijiao2 = 0;
	}
	else
	{
		tem1 = temp % 100;
		shiyuan = (temp - tem1) / 100;
		tem2 = tem1 % 10;
		yiyuan2 = (tem1 - tem2) / 10;
		yijiao2 = tem2;
		
	}
	printf("%d %d %d ", shiyuan, yiyuan2, yijiao2);
	
	return 0;
}

*/



/*
问题描述
本关任务：编写一个使一个4位二进制转换为十进制的程序。

相关知识
为了完成本关任务，你需要掌握如下知识：

进制转换
例如：
    （101111）2= （47）10

编程要求
键盘输入一个任意4位的二进制数，计算出它对应的十进制数。
提示：二进制数的每一位从低到高是1位（也是个位）、2位、4位、8位，1、2、4、8分别称为该位的基数或权。对于给定的二进制数可以按权展开，
如（1110）2 = 1×8+1×4+1×2+0×1 = （14）10，求出其对应的十进制数是14。

测试说明
平台会对你编写的代码进行测试：

测试输入：1110
预期输出：14；

思路：可能会有同学想到输入进来的是十进制数，我直接模10循环一个个得到各二进制位的数值。 


*/

/*
#include<stdio.h>
#include<string.h>
#include<math.h>
int main(void)
{
	int i, k =0;
	char a[17];
	gets(a);
	int n, sum = 0;
	n = strlen(a);
	for(i=n-1, k=0; i>= 0; i--, k++)
	{
		sum += (a[i] - 48)*pow(2, k);
	}
	printf("%d", sum);
	return 0;
}
*/


// 复习一下指针内容 
//下面的指向即为存储 

#include<stdio.h>
#include<stdlib.h>


int main(void)
{
	int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
	int *p=a;  // *表明p是指针  将a赋值给p 
	p += 6;
	printf("&a %d\n", &a);  // 6487520  自己存自己的地址 他的值，即为它指向的地址 也就是他本身的地址 
	
	printf("*a %d\n", *a);   // 6487520  *a和 a[0]指向同一个地址 
	 
	printf("**a %d\n  ", **a);  // 0 *a和 a[0]指向同一个地址  **a就是这个地址的值 
	
	printf("*a[0] %d\n", *a[0]);  // 0 *a[0]也是*a的这个地址的值 即**a 
	
	printf("a[0][0] %d\n", a[0][0]);   // 0 &a[0][0]即*a的这个地址  即a[0][0]=**a 
	
	printf("*p %d\n", *p);  // 6 p指向a的值 即a[0] 所以p+=6 即a[0]+6 所以*p=*(a[0]+6)
	printf("*(a[0]+6) %d\n", *(a[0]+6)); // 6 
	
	printf("a+6 %d\n", a+6); // 6487616 比 6487520 多了 96个字节 
	 // 地址相加，int地址之间隔4个字节，但他是二维数组的首地址 同时也是三个一维数组的首地址，他加的时候是一行一行的加的
	 // 也就是由第一个一维数组的首地址加到第二个一维数组的首地址，一维数组有4个元素，他加1相当于加一下子加了4个相邻地址之间的字节
	 // 1个相邻地址之间的字节为4，4个相邻地址之间的字节为即为16，即加1相当于加了16个字节，加6相当于加了96个字节
	  
	printf("a[0]+6 %d\n", a[0]+6);  
	// 6487544 比 6487520 多了24 a[0]是二维数组中一维数组的首地址，所以他是相邻地址之间的相加，加6即加了24个字节 
	
	printf("p %d\n", p); // 6487544 p指向a的值 即a[0] 所以p+=6 即a[0]+6
	printf("*(&a[0][0]+6) %d", *(&a[0][0]+6)); // 6 &a[0][0]同样是相邻地址之间的相加，6即是储存在 地址相加后得到的地址中 
	
	return 0;
} 

















